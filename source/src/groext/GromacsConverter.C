/*----------------------------------------------------------------------
*MODYLAS ver. 1.1.0 
*
*Copyright (c) 2014-2019 Nagoya University
*              2020-2023 The University of Tokyo
*
*Released under the MIT license.
*see https://opensource.org/licenses/MIT
*-----------------------------------------------------------------------
*MODYLAS Developers:
*Yoshimichi Andoh, Kazushi Fujimoto, Tatsuya Sakashita, Noriyuki Yoshii, 
*Zhiye Tang, Jiachao Zhang, Yuta Asano, Ryo Urano, Tetsuro Nagai, 
*Atsushi Yamada, Hidekazu Kojima, Kensuke Iwahashi, Fumiyasu Mizutani, 
*Shin-ichi Ichikawa, and Susumu Okazaki.
*----------------------------------------------------------------------*/
#include "GromacsConverter.h"
#include <iostream>
#include <fstream>
#include <set>
#include <math.h>
#include <stack>
#include <stdlib.h>
#include <map>
#include <algorithm>

bool GromacsConverter::Gromacs2Modylas( const GromacsData& gmx_data, ModylasData& mod_data,
                                        EConstraints eConstraints)
{
  //cout << "Info) Converting Gromacs to MODYLAS ..." << endl;
  
  // GROATOMs and GROCELL to mdxyz
  {
    const vector<GROATOM>& atoms = gmx_data.m_groatoms;
    const GROCELL&         cell  = gmx_data.m_grocell;
    
    int natoms = atoms.size();

    ModylasTagData& root_tag = mod_data.m_mdxyz_root_tag;

    // <atom>
    double move[3];
    move[0] = ( cell.v1[0] + cell.v2[0] + cell.v3[0] ) * 0.5;
    move[1] = ( cell.v1[1] + cell.v2[1] + cell.v3[1] ) * 0.5;
    move[2] = ( cell.v1[2] + cell.v2[2] + cell.v3[2] ) * 0.5;
    ModylasTagData* atom_tag = root_tag.AddTagData( "atom" );
    atom_tag->AddKeyValue( "natom", natoms );
    ModylasTagData* pos_tag = atom_tag->AddTagData( "positions", 3 );
    for( int i = 0; i < natoms; ++i ) {
      for( int j = 0; j < 3; ++j ) {
        pos_tag->AddString( (atoms[i].pos[j] - move[j]) * NM_TO_A );
      }
    }
    
    // atom velocities
    ModylasTagData* vel_tag = atom_tag->AddTagData( "velocities", 3 );
    for( int i = 0; i < natoms; ++i ) {
      for( int j = 0; j < 3; ++j ) {
        vel_tag->AddString( atoms[i].vel[j] * NM_TO_A * 1.0e+12);
      }
    }
    
    // <thermostat>
    int nthermo = 5;
    
    ModylasTagData* thermo_tag = root_tag.AddTagData( "thermostat" );
    thermo_tag->AddKeyValue( "nthermostat", nthermo );
    
    ModylasTagData* tpos_tag = thermo_tag->AddTagData( "positions" );
    for( int i = 0; i < nthermo; ++i ) {
      tpos_tag->AddString( 0.0 );
    }
    
    ModylasTagData* tvel_tag = thermo_tag->AddTagData( "velocities" );
    for( int i = 0; i < nthermo; ++i ) {
      tvel_tag->AddString( 0.0 );
    }
    
    // <barostat>
    int nbaro = 5;
    
    ModylasTagData* baro_tag = root_tag.AddTagData( "barostat" );
    baro_tag->AddKeyValue( "nbarostat", nbaro );
    
    ModylasTagData* bpos_tag = baro_tag->AddTagData( "positions" );
    for( int i = 0; i < nbaro; ++i ) {
      bpos_tag->AddString( 0.0 );
    }
    
    ModylasTagData* bvel_tag = baro_tag->AddTagData( "velocities" );
    for( int i = 0; i < nbaro; ++i ) {
      bvel_tag->AddString( 0.0 );
    }
    
    // <periodic cell>
    ModylasTagData* pcell_tag = root_tag.AddTagData( "periodic cell" );
    
    ModylasTagData* length_tag = pcell_tag->AddTagData( "length" );
    const double* v1 = cell.v1;
    const double* v2 = cell.v2;
    const double* v3 = cell.v3;
    double a = sqrt( v1[0] * v1[0] + v1[1] * v1[1] + v1[2] * v1[2]);
    double b = sqrt( v2[0] * v2[0] + v2[1] * v2[1] + v2[2] * v2[2]);
    double c = sqrt( v3[0] * v3[0] + v3[1] * v3[1] + v3[2] * v3[2]);
    length_tag->AddString( a * NM_TO_A );
    length_tag->AddString( b * NM_TO_A );
    length_tag->AddString( c * NM_TO_A );

    ModylasTagData* angle_tag = pcell_tag->AddTagData( "angle" );
    double alpha = acos((v2[0] * v3[0] + v2[1] * v3[1] + v2[2] * v3[2]) / ( b * c ));
    double beta  = acos((v3[0] * v1[0] + v3[1] * v1[1] + v3[2] * v1[2]) / ( c * a ));
    double gamma = acos((v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]) / ( a * b ));
    angle_tag->AddString( alpha * 180.0 / PI );
    angle_tag->AddString( beta  * 180.0 / PI );
    angle_tag->AddString( gamma * 180.0 / PI );

    ModylasTagData* vboxg_tag = pcell_tag->AddTagData( "vboxg", 3 );
    for( int i = 0; i < 9; ++i ) {
      vboxg_tag->AddString( 0.0 );
    }
  }

  // top parametes to mdff
  { 
    ModylasTagData& root_tag = mod_data.m_mdff_root_tag;

    root_tag.AddComment( "this mdff was generated by groext from GROMACS's topology file" );

    // <forcefield>
    ModylasTagData* ff_tag = root_tag.AddTagData( "forcefield" );
    String modylas_type = "";
    ForceFieldType force_field_type ;
    if (gmx_data.m_defaults.comb_rule == 2 && gmx_data.m_defaults.fudgeLJ == 1 &&  gmx_data.m_defaults.fudgeQQ == 1){
       force_field_type = ForceFieldType::charmm;
       modylas_type = "charmm";
    }else if(gmx_data.m_defaults.comb_rule == 2){
      force_field_type = ForceFieldType::gaff;
       modylas_type = "gaff";
    }
    else if(gmx_data.m_defaults.comb_rule == 3){
      force_field_type = ForceFieldType::opls;
       modylas_type = "oplsaa";
    }else{
      force_field_type = ForceFieldType::unsupported ;
      cerr << "ERROR) Currently, your input is not supported." << modylas_type << endl;
      cerr << "ERROR) Combination rule, fudgeLJ, and fudgeQQ must correspond to that of charmm, opls, and amber." << endl;
      return false;
    }
    
    //if( gmx_data.m_defaults.comb_rule == 2 ) modylas_type = "charmm";
    //if( gmx_data.m_defaults.comb_rule == 3 ) modylas_type = "oplsaa";
    //if( gmx_data.m_defaults.comb_rule == 100 ) modylas_type = "gaff";
    //if( modylas_type == "" ) {
    //  cerr << "ERROR) Could not determine type from combination rule." << modylas_type << endl;
    //  return false;
    //}

    ff_tag->AddKeyValue( "type", modylas_type );
    if( modylas_type == "charmm" )
      ff_tag->AddKeyValue( "cmap_version", 22 );
    ff_tag->AddKeyValue( "special_divide_lj"     , 1.0 / gmx_data.m_defaults.fudgeLJ );
    ff_tag->AddKeyValue( "special_divide_coulomb", 1.0 / gmx_data.m_defaults.fudgeQQ );

    // <system>
    int nspec = gmx_data.m_mols.size();
    ModylasTagData* system_tag = root_tag.AddTagData( "system", 2 );
    for( int i = 0; i < nspec; ++i ) {
      system_tag->AddString( i );
      system_tag->AddString( String(gmx_data.m_mols[i].nmol) + " # " + gmx_data.m_mols[i].molname);
    }

    map<String, String> mapAtypeBtype;
    for(unsigned int i = 0; i < gmx_data.m_atomtypes.size(); ++i) {
      mapAtypeBtype[gmx_data.m_atomtypes[i].name] = gmx_data.m_atomtypes[i].btype;
    }

    // <topology and parameters>
    ModylasTagData* topo_tag = root_tag.AddTagData( "topology and parameters" );
    topo_tag->AddKeyValue( "nspecies", nspec );

    for( int ispec = 0; ispec < nspec; ++ispec ) { 
      const String& molname = gmx_data.m_mols[ispec].molname;
      int imoltype = -1;
      for( unsigned int i = 0; i < gmx_data.m_moltypes.size(); ++i ) {
        if( molname == gmx_data.m_moltypes[i].name ) {
          imoltype = i;
          break;
        }
      }
      if( imoltype < 0 ) {
        cerr << "ERROR) Unknown moleculename " << molname << endl;
        return false;
      }
      const TOPMOLECULETYPE& moltype = gmx_data.m_moltypes[imoltype];
    
      const vector<TOPATOM>& rAtoms = moltype.atoms;
      int natom = rAtoms.size();
    
      ModylasTagData* spec_tag = topo_tag->AddTagData( "species" );
      spec_tag->AddKeyValue( "id"   , ispec );
      spec_tag->AddKeyValue( "natom", natom );
    
      ModylasTagData* mass_tag = spec_tag->AddTagData( "mass" );
      mass_tag->AddComment("      mass        type    atom (in gmx) ");
      for( int i = 0; i < natom; ++i ) {
        double mass = 0.0;
        if( rAtoms[i].bHasMass ) {
          mass = rAtoms[i].mass;
        }
        else {
          const String& type = rAtoms[i].type;
          unsigned int j = 0;
          for( ; j < gmx_data.m_atomtypes.size(); ++j ) {
            if( type == gmx_data.m_atomtypes[j].name ) {
              mass = gmx_data.m_atomtypes[j].mass;
              break;
            }
          }
          if( j == gmx_data.m_atomtypes.size() ) {
            cerr << "ERROR) Failed to set mass value for atom type " << type << endl;
            return false;
          }
        }
        mass_tag->AddString( String(mass) + " # " + rAtoms[i].type + " " + rAtoms[i].name);
      }

      // Split bonds and shakes
      const vector<TOPBOND>& rBonds = moltype.bonds;
      vector<TOPBOND> mod_bonds;
      vector<TOPBOND> mod_shakes;
      if( eConstraints == CONSTRAINTS_NONE ) {
        mod_bonds = rBonds;
      }
      else if( eConstraints == CONSTRAINTS_ALLBONDS ) {
        mod_shakes = rBonds;
      }
      else if( eConstraints == CONSTRAINTS_HBONDS ) {
        for( int i = 0; i < rBonds.size(); ++i ) {
          int i0 = rBonds[i].ai - 1;
          int i1 = rBonds[i].aj - 1;
          const String& name0 = rAtoms[i0].type;
          const String& name1 = rAtoms[i1].type;
          const String& btype0 = mapAtypeBtype[name0];
          const String& btype1 = mapAtypeBtype[name1];
          String h0 = btype0.substr(0, 1).ToUpper();
          String h1 = btype1.substr(0, 1).ToUpper();
          if( h0 == "H" || h1 == "H" ) {
            mod_shakes.push_back(rBonds[i]);
          }
          else {
            mod_bonds.push_back(rBonds[i]);
          }
        }
      }

      // make shaked from settels
      const vector<TOPSETTLE>& rSettles = moltype.settles;
      for( int i = 0; i < rSettles.size(); ++i ) {
        int iow = rSettles[i].iow;
        int ih0 = iow + 1;
        int ih1 = iow + 2;
        double doh = rSettles[i].doh;
        double dhh = rSettles[i].dhh;
        mod_shakes.push_back(TOPBOND(iow, ih0, 1, true, doh, 0.0));
        mod_shakes.push_back(TOPBOND(iow, ih1, 1, true, doh, 0.0));
        mod_shakes.push_back(TOPBOND(ih0, ih1, 1, true, dhh, 0.0));
      }

      int nshake = mod_shakes.size();
      ModylasTagData* shake_tag = spec_tag->AddTagData( "shake pair", 3 );
      for( int i = 0; i < nshake; ++i ) {
        int i0 = mod_shakes[i].ai - 1;
        int i1 = mod_shakes[i].aj - 1;
        int funct = mod_shakes[i].funct;
        const String& name0 = rAtoms[i0].type;
        const String& name1 = rAtoms[i1].type;
        const String& btype0 = mapAtypeBtype[name0];
        const String& btype1 = mapAtypeBtype[name1];
        double r = 0.0;
        if( mod_shakes[i].bHasR ) {
          r = mod_shakes[i].r;
        }
        else{
          unsigned int j = 0;
          for( ; j < gmx_data.m_bondtypes.size(); ++j ) {
            if( funct != gmx_data.m_bondtypes[j].funct) continue;
            if( ( btype0 == gmx_data.m_bondtypes[j].namei && btype1 == gmx_data.m_bondtypes[j].namej ) ||
                ( btype0 == gmx_data.m_bondtypes[j].namej && btype1 == gmx_data.m_bondtypes[j].namei ) ) {
              r = gmx_data.m_bondtypes[j].r;
              break;
            }
          }
          if( j == gmx_data.m_bondtypes.size() ) {
            cerr << "ERROR) Failed to set shake r value for bond type "
                 << name0 << " " << name1 << endl;
            return false;
          }
        }
        shake_tag->AddString( i0 );
        shake_tag->AddString( i1 );
        shake_tag->AddString( r * NM_TO_A );
      }

      ModylasTagData* charge_tag = spec_tag->AddTagData( "charge" );
      for( int i = 0; i < natom; ++i ) {
        double charge = 0.0;
        if( rAtoms[i].bHasCharge ) {
          charge = rAtoms[i].charge;
        }
        else {
          const String& type = rAtoms[i].type;
          unsigned int j = 0;
          for( ; j < gmx_data.m_atomtypes.size(); ++j ) {
            if( type == gmx_data.m_atomtypes[j].name ) {
              charge = gmx_data.m_atomtypes[j].charge;
              break;
            }
          }
          if( j == gmx_data.m_atomtypes.size() ) {
            cerr << "ERROR) Failed to set charge value for atom type " << type << endl;
            return false;
          }
        }
        charge_tag->AddString( charge );
      }

      // void pairs from nrexcl
      vector<set<int> > vVoidPair(natom);
      int nrexcl = moltype.nrexcl;
      if( 0 < nrexcl ) {
        vector<set<int> > vbond01(natom);
        for( int i = 0; i < rBonds.size(); ++i ) {
          int i0 = rBonds[i].ai - 1;
          int i1 = rBonds[i].aj - 1;
          vbond01[i0].insert(i1);
          vbond01[i1].insert(i0);
        }
        vVoidPair = vbond01;
        for(int iexcl = 1; iexcl < nrexcl; ++iexcl) {
          for( int i = 0; i < natom; ++i ) {
            set<int> setVoid = vVoidPair[i];
            set<int>::const_iterator it1 = setVoid.begin();
            for( ; it1 != setVoid.end(); ++it1 ) {
              int i1 = *it1;
              vVoidPair[i].insert(vbond01[i1].begin(), vbond01[i1].end());
            }
            vVoidPair[i].erase(i);
          }
        }
      }

      // void pairs from exclustions
      vector<TOPEXCLUSION> rExclusions = moltype.exclusions;
      for( int i = 0; i < rExclusions.size(); ++i ) {
        int i0 = rExclusions[i].ai;
        for( int j = 0; j < rExclusions[i].vaj.size(); ++j ) {
          int i1 = rExclusions[i].vaj[j];
          vVoidPair[i0-1].insert(i1-1);
        }
      }

      // remove pairs from void pairs
      const vector<TOPPAIR>& rPairs = moltype.pairs;
      int npair = rPairs.size();
      for( unsigned int i = 0; i < npair; ++i ) {
        int i0 = rPairs[i].ai - 1;
        int i1 = rPairs[i].aj - 1;
        vVoidPair[i0].erase(i1);
        vVoidPair[i1].erase(i0);
      }

      int ncoulomb = 0;
      ModylasTagData* coul_tag = spec_tag->AddTagData( "coulomb void pair", 2 );
      for( int i = 0; i < natom; ++i ) {
        set<int>::const_iterator it = vVoidPair[i].begin();
        for( ; it != vVoidPair[i].end(); ++it ) {
          int j = *it;
          coul_tag->AddString( i );
          coul_tag->AddString( j );
        }
        ncoulomb += vVoidPair[i].size();
      }
      spec_tag->AddKeyValue( "nvoidpair_coulomb", ncoulomb );

      ModylasTagData* eps_tag = spec_tag->AddTagData( "epsilon" );
      for( int i = 0; i < natom; ++i ) {
        double epsilon = 0.0;
        const String& type = rAtoms[i].type;
        unsigned int j = 0;
        for( ; j < gmx_data.m_atomtypes.size(); ++j ) {
          if( type == gmx_data.m_atomtypes[j].name ) {
            epsilon = gmx_data.m_atomtypes[j].epsilon;
            break;
          }
        }
        if( j == gmx_data.m_atomtypes.size() ) {
          cerr << "ERROR) Failed to set epsilon value for atom type " << type << endl;
          return false;
        }
        epsilon *= KJ_TO_KCAL;
        eps_tag->AddString( epsilon );
      }

      ModylasTagData* r_tag = spec_tag->AddTagData( "r" );
      if( force_field_type == ForceFieldType::opls or force_field_type==ForceFieldType::gaff ) { // oplsaa or gaff
        r_tag->AddComment("CAUTION: As type=oplsaa or gaff is set, in this so-called \"<r>\" tag, sigma (zero crosspoint) is actually");
        r_tag->AddComment("(and thus very very confusingly) provided instead of r (minimum point)");
      }
      for( int i = 0; i < natom; ++i ) {
        double sigma = 0.0;
        const String& type = rAtoms[i].type;
        unsigned int j = 0;
        for( ; j < gmx_data.m_atomtypes.size(); ++j ) {
          if( type == gmx_data.m_atomtypes[j].name ) {
            sigma = gmx_data.m_atomtypes[j].sigma;
            break;
          }
        }
        if( j == gmx_data.m_atomtypes.size() ) {
          cerr << "ERROR) Failed to set sigma value for atom type " << type << endl;
          return false;
        }
        double r = sigma * NM_TO_A;
        if( modylas_type == "charmm" ) {
          r *= SIGMA_TO_R;
        }
        r_tag->AddString( r );
      }

      int nljvoid = 0;
      ModylasTagData* ljvoid_tag = spec_tag->AddTagData( "lj void pair", 2 );
      for( int i = 0; i < natom; ++i ) {
        set<int>::const_iterator it = vVoidPair[i].begin();
        for( ; it != vVoidPair[i].end(); ++it ) {
          int j = *it;
          ljvoid_tag->AddString( i );
          ljvoid_tag->AddString( j );
        }
        nljvoid += vVoidPair[i].size();
      }
      spec_tag->AddKeyValue( "nvoidpair_lj", nljvoid );

      if( force_field_type == ForceFieldType::charmm ) { // only for charmm
        // Set sigm_i and epsilon_i instead of sigma_ij and epsilon_ij for lj special pair
        ModylasTagData* ljspec_tag = spec_tag->AddTagData( "lj special pair", 4 );
        ljspec_tag->AddComment("NOTICE!!");
        ljspec_tag->AddComment("epsilon_ii^special and r_ii^special were generated from epsilon_ij and sigma_ij");
        ljspec_tag->AddComment("by assuming epsilon_jj^special r_jj^special to take default values specified in atomtypes");
        ljspec_tag->AddComment("(and, thus, epslion_jj > 0  should hold). ");
        ljspec_tag->AddComment("As such, the values listed here may be different from CHARMM's original ones, but still you");
        ljspec_tag->AddComment("can expect that epsilon_ij and sigma_ij are correctly specified!! OMG!! ");
        ljspec_tag->AddComment(" i   j      epsilon_i^special  r_i^special ");
        for( unsigned int i = 0; i < npair; ++i ) {
          int i0 = rPairs[i].ai - 1;
          int i1 = rPairs[i].aj - 1;
          const String& name0 = rAtoms[i0].type;
          const String& name1 = rAtoms[i1].type;
          double sigma    = 0.0;
          double epsilon  = 0.0;
          double sigma0   = 0.0;
          double epsilon0 = 0.0;
          bool bHasSigma = false;
          if( rPairs[i].bHasSigma ) {
            sigma   = rPairs[i].sigma;
            epsilon = rPairs[i].epsilon;
            bHasSigma = true;
          }
          else {
            for( unsigned int j = 0; j < gmx_data.m_pairtypes.size(); ++j ) {
              const String& namei = gmx_data.m_pairtypes[j].namei;
              const String& namej = gmx_data.m_pairtypes[j].namej;
              if( (name0 == namei && name1 == namej) ||
                  (name0 == namej && name1 == namei) ) {
                sigma   = gmx_data.m_pairtypes[j].sigma;
                epsilon = gmx_data.m_pairtypes[j].epsilon;
                bHasSigma = true;
                break;
              }
            }
          }
          if( bHasSigma ) {
            double sigma1   = 0.0;
            double epsilon1 = 0.0;
            unsigned int j = 0;
            for( ; j < gmx_data.m_atomtypes.size(); ++j ) {
              if( name1 == gmx_data.m_atomtypes[j].name ) {
                sigma1   = gmx_data.m_atomtypes[j].sigma;
                epsilon1 = gmx_data.m_atomtypes[j].epsilon;
                break;
              }
            }
            if( j == gmx_data.m_atomtypes.size() ) {
              cerr << "ERROR) Failed to set sigma and epsilon value for atom type "
                   << name1 << endl;
              return false;
            }
            sigma0   = sigma * 2 - sigma1;
            epsilon0 = epsilon * epsilon / epsilon1;
          }
          else {
            unsigned j = 0;
            for( ; j < gmx_data.m_atomtypes.size(); ++j ) {
              if( name0 == gmx_data.m_atomtypes[j].name ) {
                sigma0   = gmx_data.m_atomtypes[j].sigma;
                epsilon0 = gmx_data.m_atomtypes[j].epsilon;
                break;
              }
            }
            if( j == gmx_data.m_atomtypes.size() ) {
              cerr << "ERROR) Failed to set sigma and epsilon value for atom type "
                   << name0 << endl;
              return false;
            }
          }
        
          double r0 = sigma0 * SIGMA_TO_R * NM_TO_A;
          epsilon0 *= KJ_TO_KCAL;
          ljspec_tag->AddString( i0       );
          ljspec_tag->AddString( i1       );
          ljspec_tag->AddString( epsilon0 );
          ljspec_tag->AddString( r0       );
        }
        spec_tag->AddKeyValue( "nspecialpair_lj", npair );
      }

      int nbond = mod_bonds.size();
      spec_tag->AddKeyValue( "nbond", nbond );
      ModylasTagData* bond_tag = spec_tag->AddTagData( "bond", 4 );
      for( int i = 0; i < nbond; ++i ) {
        int i0    = mod_bonds[i].ai - 1;
        int i1    = mod_bonds[i].aj - 1;
        int funct = mod_bonds[i].funct;
        if( 2 < funct ) {
          cerr << "ERROR) Unknown bond funct type " << funct << endl;
          return false;
        }
        const String& name0 = rAtoms[i0].type;
        const String& name1 = rAtoms[i1].type;
        const String& btype0 = mapAtypeBtype[name0];
        const String& btype1 = mapAtypeBtype[name1];
        double r = 0.0;
        double k = 0.0;
        if( mod_bonds[i].bHasR ) {
          r = mod_bonds[i].r;
          k = mod_bonds[i].k;
        }
        else{
          unsigned int j = 0;
          for( ; j < gmx_data.m_bondtypes.size(); ++j ) {
            const TOPBONDTYPE& bondtype = gmx_data.m_bondtypes[j];
            if( funct != bondtype.funct) continue;
            if( ( btype0 == bondtype.namei && btype1 == bondtype.namej ) ||
                ( btype0 == bondtype.namej && btype1 == bondtype.namei ) ) {
              r = bondtype.r;
              k = bondtype.k;
              break;
            }
          }
          if( j == gmx_data.m_bondtypes.size() ) {
            cerr << "ERROR) Failed to set r and k value for bond type "
                 << name0 << " " << name1 << endl;
            return false;
          }
        }
        bond_tag->AddString( i0 );
        bond_tag->AddString( i1 );
        k *= 0.5 * KJ_TO_KCAL * A_TO_NM * A_TO_NM;
        if( funct == 2 ) {
          k *= A_TO_NM * A_TO_NM;
        }
        bond_tag->AddString( k );
        bond_tag->AddString( r * NM_TO_A );
      }

      const vector<TOPANGLE>& rAngles = moltype.angles;
      int nangle = rAngles.size();
      spec_tag->AddKeyValue( "nangle", nangle );
      ModylasTagData* angle_tag = spec_tag->AddTagData( "angle", 5 );
      for( int i = 0; i < nangle; ++i ) {
        int i0 = rAngles[i].ai - 1;
        int i1 = rAngles[i].aj - 1;
        int i2 = rAngles[i].ak - 1;
        double theta0 = 0.0;
        double ktheta = 0.0;
        if( rAngles[i].bHasThetaK ) {
          theta0 = rAngles[i].theta;
          ktheta = rAngles[i].k * 0.5 * KJ_TO_KCAL;
        }
        else {
          const String& name0 = rAtoms[i0].type;
          const String& name1 = rAtoms[i1].type;
          const String& name2 = rAtoms[i2].type;
          const String& btype0 = mapAtypeBtype[name0];
          const String& btype1 = mapAtypeBtype[name1];
          const String& btype2 = mapAtypeBtype[name2];
          int funct = rAngles[i].funct;
          unsigned int j = 0;
          for( ; j < gmx_data.m_angletypes.size(); ++j ) {
            const TOPANGLETYPE& angtype = gmx_data.m_angletypes[j];
            if( funct  != angtype.funct ) continue;
            if( btype1 != angtype.namej ) continue;
            if( ( btype0 == angtype.namei && btype2 == angtype.namek ) ||
                ( btype0 == angtype.namek && btype2 == angtype.namei ) ) {
              theta0 = angtype.theta;
              ktheta = angtype.k * 0.5 * KJ_TO_KCAL;
              break;
            }
          }
          if( j == gmx_data.m_angletypes.size() ) {
            cerr << "ERROR) Failed to set theta_0 and k_theta value for angle type "
                 << name0 << " " << name1 << " " << name2 << endl;
            return false;
          }
        }
        angle_tag->AddString( i0 );
        angle_tag->AddString( i1 );
        angle_tag->AddString( i2 );
        angle_tag->AddString( ktheta );
        angle_tag->AddString( theta0 );
      }

      const vector<TOPCMAP>& rCmaps = moltype.cmaps;
      int ncmap = rCmaps.size();
      spec_tag->AddKeyValue( "ncmap", ncmap );
      ModylasTagData* cmap_tag = spec_tag->AddTagData( "cmap", 6 );
      for( int i = 0; i < ncmap; ++i ) {
        int i0 = rCmaps[i].ai - 1;
        int i1 = rCmaps[i].aj - 1;
        int i2 = rCmaps[i].ak - 1;
        int i3 = rCmaps[i].al - 1;
        int i4 = rCmaps[i].am - 1;
        const String& name0 = rAtoms[i0].type;
        const String& name1 = rAtoms[i1].type;
        const String& name2 = rAtoms[i2].type;
        const String& name3 = rAtoms[i3].type;
        const String& name4 = rAtoms[i4].type;
        unsigned int j = 0;
        for( ; j < gmx_data.m_cmaptypes.size(); ++j ) {
          const String& namei = gmx_data.m_cmaptypes[j].namei;
          const String& namej = gmx_data.m_cmaptypes[j].namej;
          const String& namek = gmx_data.m_cmaptypes[j].namek;
          const String& namel = gmx_data.m_cmaptypes[j].namel;
          const String& namem = gmx_data.m_cmaptypes[j].namem;
          if( name0 == namei && name1 == namej && name2 == namek && name3 == namel && name4 == namem ) {
            break;
          }
        }
        if( j == gmx_data.m_cmaptypes.size() ) {
          cerr << "ERROR) Failed to set cmap index for cmap type "
               << name0 << " " << name1 << " " << name2 << " " << name3 << " " << name4 << endl;
          return false;
        }
        cmap_tag->AddString( i0 );
        cmap_tag->AddString( i1 );
        cmap_tag->AddString( i2 );
        cmap_tag->AddString( i3 );
        cmap_tag->AddString( i4 );
        cmap_tag->AddString( int(j + 1) );
      }

      int nub = 0;
      ModylasTagData* ub_tag = spec_tag->AddTagData( "ub", 5 );
      for( int i = 0; i < nangle; ++i ) {
        int funct = rAngles[i].funct;
        if( funct != 5 ) continue;
        int i0 = rAngles[i].ai - 1;
        int i1 = rAngles[i].aj - 1;
        int i2 = rAngles[i].ak - 1;
        const String& name0 = rAtoms[i0].type;
        const String& name1 = rAtoms[i1].type;
        const String& name2 = rAtoms[i2].type;
        double ub0 = 0.0;
        double cub = 0.0;
        if( rAngles[i].bHasUB ) {
          ub0 = rAngles[i].ub0;
          cub = rAngles[i].cub;
        }
        else {
          unsigned int j = 0;
          for( ; j < gmx_data.m_angletypes.size(); ++j ) {
            const TOPANGLETYPE& angtype= gmx_data.m_angletypes[j];
            if( funct != angtype.funct ) continue;
            if( name1 != angtype.namej ) continue;
            if( ( name0 == angtype.namei && name2 == angtype.namek ) ||
                ( name0 == angtype.namek && name2 == angtype.namei ) ) {
              ub0 = angtype.ub0;
              cub = angtype.cub;
              break;
            }
          }
          if( j == gmx_data.m_angletypes.size() ) {
            cerr << "ERROR) Failed to set k_ub and s_0 value for angle type "
                 << name0 << " " << name1 << " " << name2 << endl;
            return false;
          }
        }
        double kub = cub * 0.5 * KJ_TO_KCAL / (NM_TO_A * NM_TO_A);
        double s0  = ub0 * NM_TO_A;
        ub_tag->AddString( i0  );
        ub_tag->AddString( i1  );
        ub_tag->AddString( i2  );
        ub_tag->AddString( kub );
        ub_tag->AddString( s0  );
        ++nub;
      }
      spec_tag->AddKeyValue( "nub", nub );

      const vector<TOPDIHEDRAL>& rDihedrals = moltype.dihedrals;
      int ndihedral = 0;
      ModylasTagData* dihedral_tag = spec_tag->AddTagData( "dihedral", 7 );
      dihedral_tag->AddComment("function form is K(1-cos(n phi -phi_0)) for type=charmm");
      dihedral_tag->AddComment("function form is 0.5 * K*(1-cos(n phi  -phi_0)) for type=oplsaa.");
      dihedral_tag->AddComment("function form is K(1-cos(n phi -phi_0)) for type=gaff ");
      for( unsigned int i = 0; i < rDihedrals.size(); ++i ) {
        int funct = rDihedrals[i].funct;

        if( funct == 2 ) continue; //skip as funct == 2 is charmm type improper dihedral
        
        const bool bUseNonCharmmItorsion = force_field_type==ForceFieldType::gaff or force_field_type == ForceFieldType::opls; 
        if( bUseNonCharmmItorsion && (funct == 1 ||funct == 4)) continue; 
        //skip processing for funct == 1, as these entries are used for itorsion, following gromacs's (somewhat weired) OPLS convention...
        //skip processing for funct == 4, as these entries  are for improper dihedral by definition.
        
        int i0 = rDihedrals[i].ai - 1;
        int i1 = rDihedrals[i].aj - 1;
        int i2 = rDihedrals[i].ak - 1;
        int i3 = rDihedrals[i].al - 1;
        if( funct == 3 ) {
          double c0 = 0.0;
          double c1 = 0.0;
          double c2 = 0.0;
          double c3 = 0.0;
          double c4 = 0.0;
          double c5 = 0.0;
          if( rDihedrals[i].bHasC ) {
            c0 = rDihedrals[i].c0;
            c1 = rDihedrals[i].c1;
            c2 = rDihedrals[i].c2;
            c3 = rDihedrals[i].c3;
            c4 = rDihedrals[i].c4;
            c5 = rDihedrals[i].c5;
          }
          else {
            int j = SearchDihedralType(rDihedrals[i], gmx_data.m_dihedraltypes,
                                       rAtoms, mapAtypeBtype);
            if( j < 0 ) return false;
            c0 = gmx_data.m_dihedraltypes[j].c0;
            c1 = gmx_data.m_dihedraltypes[j].c1;
            c2 = gmx_data.m_dihedraltypes[j].c2;
            c3 = gmx_data.m_dihedraltypes[j].c3;
            c4 = gmx_data.m_dihedraltypes[j].c4;
            c5 = gmx_data.m_dihedraltypes[j].c5;
          }
          double k5 = -c5 / 16.0;
          double k4 = c4 / 8.0;
          double k3 = (-c3 + 20.0 * k5) / 4.0;
          double k2 = (c2 + 8.0 * k4) / 2.0;
          double k1 = -c1 + 3.0 * k3 - 5.0 * k5;
          double k0 = (c0 - k1 - k3 - 2.0 * k4 - k5) / 2.0;

          for(int k = 0; k < 6; ++k) {
            double kchi  = 0.0;
            switch(k){
            case 0: kchi = k0; break;
            case 1: kchi = k1; break;
            case 2: kchi = k2; break;
            case 3: kchi = k3; break;
            case 4: kchi = k4; break;
            case 5: kchi = k5; break;
            }
            kchi *= KJ_TO_KCAL;
            int    n     = k;
            double delta = 0.0;
            if( gmx_data.m_defaults.comb_rule == 3 ) { // oplsaa
              kchi *= 2.0;
            }

            dihedral_tag->AddString( i0 );
            dihedral_tag->AddString( i1 );
            dihedral_tag->AddString( i2 );
            dihedral_tag->AddString( i3 );
            dihedral_tag->AddString( kchi  );
            dihedral_tag->AddString( n     );
            dihedral_tag->AddString( delta );
            ++ndihedral;
          }
        }
        else {
          // funct = 1 or 9
          double kchi  = 0.0;
          double delta = 0.0;
          int n        = 0;
          if( rDihedrals[i].bHasPhase ) {
            if( !rDihedrals[i].bHasN ) continue;
            n     = rDihedrals[i].pn;
            kchi  = rDihedrals[i].kd * KJ_TO_KCAL;
            delta = rDihedrals[i].phase;

            if( force_field_type == ForceFieldType::opls ) { // oplsaa
              kchi *= 2.0;
            }

            dihedral_tag->AddString( i0 );
            dihedral_tag->AddString( i1 );
            dihedral_tag->AddString( i2 );
            dihedral_tag->AddString( i3 );
            dihedral_tag->AddString( kchi  );
            dihedral_tag->AddString( n     );
            dihedral_tag->AddString( delta );
            ++ndihedral;
          }
          else {
            if( funct == 1 ) {
              int j = SearchDihedralType(rDihedrals[i], gmx_data.m_dihedraltypes,
                                         rAtoms, mapAtypeBtype);
              if( j < 0 ) return false;

              kchi  = gmx_data.m_dihedraltypes[j].kd * KJ_TO_KCAL;
              delta = gmx_data.m_dihedraltypes[j].phase;
              n     = gmx_data.m_dihedraltypes[j].pn;

              if( force_field_type == ForceFieldType::opls ) { // oplsaa
                kchi *= 2.0;
              }

              dihedral_tag->AddString( i0 );
              dihedral_tag->AddString( i1 );
              dihedral_tag->AddString( i2 );
              dihedral_tag->AddString( i3 );
              dihedral_tag->AddString( kchi  );
              dihedral_tag->AddString( n     );
              dihedral_tag->AddString( delta );
              ++ndihedral;
            }
            else if( funct == 9 ) {
              vector<int> vj = SearchDihedralTypes(rDihedrals[i], gmx_data.m_dihedraltypes,
                                                   rAtoms, mapAtypeBtype);
              if( vj.empty() ) return false;

              for(unsigned int k = 0; k < vj.size(); ++k) {
                int j = vj[k];
                
                kchi  = gmx_data.m_dihedraltypes[j].kd * KJ_TO_KCAL;
                delta = gmx_data.m_dihedraltypes[j].phase;
                n     = gmx_data.m_dihedraltypes[j].pn;

                if( gmx_data.m_defaults.comb_rule == 3 ) { // oplsaa
                  kchi *= 2.0;
                }

                dihedral_tag->AddString( i0 );
                dihedral_tag->AddString( i1 );
                dihedral_tag->AddString( i2 );
                dihedral_tag->AddString( i3 );
                dihedral_tag->AddString( kchi  );
                dihedral_tag->AddString( n     );
                dihedral_tag->AddString( delta );
                ++ndihedral;
              }
            }
            else {
              cerr << "ERROR) Unknown dihedral funct type " << funct << endl;
              return false;
            }
          }
        }
      }
      spec_tag->AddKeyValue( "ndihedral", ndihedral );

      int nitorsion = 0;
      //int n = ( gmx_data.m_defaults.comb_rule == 3 ) ? 7 : 6;
      const bool bUseNonCharmmItorsion = force_field_type==ForceFieldType::gaff or force_field_type == ForceFieldType::opls; 
      const int n = bUseNonCharmmItorsion ? 7 : 6 ;
      //TODO
      ModylasTagData* itorsion_tag = spec_tag->AddTagData( "itorsion", n );
      itorsion_tag->AddComment("for type=charmm, harmonic function is used: k/2(xi-xi_0)^2");
      itorsion_tag->AddComment("i   j    k    l   k    xi_0");
      itorsion_tag->AddComment("for type=opls, 'proper dihedral' is used: k/2(1-cos(n phi-phi_0))");
      itorsion_tag->AddComment("i   j    k    l   k    n       phi_0");
      itorsion_tag->AddComment("for type=gaff, 'proper dihedral' is used: K(1+dcos(n phi)). This function form is based on improper dinedral cvff in Lammps");
      itorsion_tag->AddComment("i   j    k    l   K    d   n ");
      for( unsigned int i = 0; i < rDihedrals.size(); ++i ) {
        int funct = rDihedrals[i].funct;
        if( bUseNonCharmmItorsion ) {
          if( funct == 2 ) {
            cerr << "ERROR) Itorsion type must be funct = 1 for OPLS." << endl;
            return false;
          }
          if( !(funct == 1 or funct == 4) ) continue; //only process when funct == 1 or 4 for opls or gaff
        }
        else { // for charmm
          if( funct != 2 ) continue; //only process when funct == 2 for CHARMM
        }
        int i0 = rDihedrals[i].ai - 1;
        int i1 = rDihedrals[i].aj - 1;
        int i2 = rDihedrals[i].ak - 1;
        int i3 = rDihedrals[i].al - 1;
        if( funct == 2 ) {
          double kpsi = 0.0;
          double psi0 = 0.0;
          if( rDihedrals[i].bHasPhase ) {
            kpsi = rDihedrals[i].kd * 0.5 * KJ_TO_KCAL;
            psi0 = rDihedrals[i].phase;
          }
          else {
            const String& name0 = rAtoms[i0].type;
            const String& name1 = rAtoms[i1].type;
            const String& name2 = rAtoms[i2].type;
            const String& name3 = rAtoms[i3].type;
            unsigned int j = 0;
            for( ; j < gmx_data.m_dihedraltypes.size(); ++j ) {
              if( funct != gmx_data.m_dihedraltypes[j].funct ) continue;
              bool bMatch = false;
              {
                String namei = gmx_data.m_dihedraltypes[j].namei;
                String namej = gmx_data.m_dihedraltypes[j].namej;
                String namek = gmx_data.m_dihedraltypes[j].namek;
                String namel = gmx_data.m_dihedraltypes[j].namel;
                if( namei == "X" ) namei = name0;
                if( namej == "X" ) namej = name1;
                if( namek == "X" ) namek = name2;
                if( namel == "X" ) namel = name3;
                if( name0 == namei && name1 == namej && name2 == namek && name3 == namel ) {
                  bMatch = true;
                }
              }
              {
                String namei = gmx_data.m_dihedraltypes[j].namei;
                String namej = gmx_data.m_dihedraltypes[j].namej;
                String namek = gmx_data.m_dihedraltypes[j].namek;
                String namel = gmx_data.m_dihedraltypes[j].namel;
                if( namei == "X" ) namei = name3;
                if( namej == "X" ) namej = name2;
                if( namek == "X" ) namek = name1;
                if( namel == "X" ) namel = name0;
                if( name3 == namei && name2 == namej && name1 == namek && name0 == namel ) {
                  bMatch = true;
                }
              }
              if( bMatch ) {
                kpsi = gmx_data.m_dihedraltypes[j].kd * 0.5 * KJ_TO_KCAL;
                psi0 = gmx_data.m_dihedraltypes[j].phase;
                break;
              }
            }
            if( j == gmx_data.m_dihedraltypes.size() ) {
              cerr << "ERROR) Failed to set itorsion parameters for dihedral type "
                   << name0 << " " << name1 << " " << name2 << " " << name3 << endl;
              return false;
            }
          }
          itorsion_tag->AddString( i0 );
          itorsion_tag->AddString( i1 );
          itorsion_tag->AddString( i2 );
          itorsion_tag->AddString( i3 );
          itorsion_tag->AddString( kpsi );
          itorsion_tag->AddString( psi0 );
          ++nitorsion;
        }
        else { //  function type == 1 or 4.  for gaff and opls
          double kchi  = 0.0;
          double delta = 0.0;
          int n        = 0;
          if( rDihedrals[i].bHasPhase ) {
            if( !rDihedrals[i].bHasN ) continue;
            n     = rDihedrals[i].pn;
            if(force_field_type == ForceFieldType::opls){
              kchi  = rDihedrals[i].kd * 2.0 * KJ_TO_KCAL;
            }else{
              kchi  = rDihedrals[i].kd * 1.0 * KJ_TO_KCAL;
            }

            delta = rDihedrals[i].phase;

            itorsion_tag->AddString( i0 );
            itorsion_tag->AddString( i1 );
            itorsion_tag->AddString( i2 );
            itorsion_tag->AddString( i3 );
            if(force_field_type == ForceFieldType::opls){
              itorsion_tag->AddString( kchi  );
              itorsion_tag->AddString( n     );
              itorsion_tag->AddString( delta );
            }else { // gaff
              itorsion_tag->AddString( kchi  );
              int d = (delta == 0)?1:-1;  //TODO may need error check....
              itorsion_tag->AddString( d );
              itorsion_tag->AddString( n );
            }
            ++nitorsion;
          }
          else {
            int j = SearchDihedralType(rDihedrals[i], gmx_data.m_dihedraltypes,
                                       rAtoms, mapAtypeBtype);
            if( j < 0 ) return false;
            if(force_field_type == ForceFieldType::opls){
              kchi  = gmx_data.m_dihedraltypes[j].kd * 2.0 * KJ_TO_KCAL;
            }else{ //gaff
              kchi  = gmx_data.m_dihedraltypes[j].kd * 1.0 * KJ_TO_KCAL;
            }
            delta = gmx_data.m_dihedraltypes[j].phase;
            n     = gmx_data.m_dihedraltypes[j].pn;

            itorsion_tag->AddString( i0 );
            itorsion_tag->AddString( i1 );
            itorsion_tag->AddString( i2 );
            itorsion_tag->AddString( i3 );
            if(force_field_type == ForceFieldType::opls){
              itorsion_tag->AddString( kchi  );
              itorsion_tag->AddString( n     );
              itorsion_tag->AddString( delta );
            }else { //gaff
              itorsion_tag->AddString( kchi  );
              int d = (delta == 0)?1:-1;  //TODO may need error check....
              itorsion_tag->AddString( d );
              itorsion_tag->AddString( n );
            }
            ++nitorsion;
          }
        }
      }
      spec_tag->AddKeyValue( "nitorsion", nitorsion );

      ModylasTagData* segs_tag = spec_tag->AddTagData( "segments" );
      vector<set<int> > vSegs;
      for( int i = 0; i < natom; ++i ) {
        int cgnr = rAtoms[i].cgnr;
        if( (int)vSegs.size() < cgnr + 1 ) {
          vSegs.resize(cgnr + 1);
        }
        vSegs[cgnr].insert(i);
      }

      int iseg = 0;
      for(unsigned int i = 0; i < vSegs.size(); ++i) {
        if( vSegs[i].empty() ) continue;
        ModylasTagData* seg_tag = segs_tag->AddTagData( "segment" );
        seg_tag->AddKeyValue( "ID"   , iseg );
        seg_tag->AddKeyValue( "natom", (int)vSegs[i].size() );
        ModylasTagData* atom_tag = seg_tag->AddTagData( "atom" );
        set<int>::iterator it = vSegs[i].begin();
        for(; it != vSegs[i].end(); ++it) {
          atom_tag->AddString( *it );
        }
        ++iseg;
      }
      segs_tag->AddKeyValue( "nsegment", iseg );
    }
  }

  return true;
}

int GromacsConverter::SearchDihedralType(
  const TOPDIHEDRAL& dihedral,
  const vector<TOPDIHEDRALTYPE> dihedraltypes,
  const vector<TOPATOM>& rAtoms,
  const map<String, String>& mapAtypeBtype)
{
  vector<int> vi = SearchDihedralTypes(dihedral, dihedraltypes, rAtoms, mapAtypeBtype);

  return (vi.empty() ? -1 : vi[0]);
}

/*
  Gromacs dihedraltype search for funct 9
  (1) Group by block with 4 atom types. 
      e.g. "C C O C", "C O C C", "C C O X", etc. are treated as separate blocks.
      Lines with same parameters are ignored.
  (2) If "C O C C" appears after "C C O C" block, ignore if both blocks have only one line and same parameters.
      Otherwise an error.
      Same for "C O C X" and "X C O C".
  (3) When searching for a matching type
      - More X matches lower priority
      - If there is the same number of X matches, the one that comes first has priority.
 */
vector<int> GromacsConverter::SearchDihedralTypes(
  const TOPDIHEDRAL& dihedral,
  const vector<TOPDIHEDRALTYPE> dihedraltypes,
  const vector<TOPATOM>& rAtoms,
  const map<String, String>& mapAtypeBtype)
{
  vector<int> vi;
  vector<int> vnX;

  int funct = dihedral.funct;
  int i0    = dihedral.ai - 1;
  int i1    = dihedral.aj - 1;
  int i2    = dihedral.ak - 1;
  int i3    = dihedral.al - 1;
  const String& name0 = rAtoms[i0].type;
  const String& name1 = rAtoms[i1].type;
  const String& name2 = rAtoms[i2].type;
  const String& name3 = rAtoms[i3].type;
  const String& bt0 = mapAtypeBtype.find(name0)->second;
  const String& bt1 = mapAtypeBtype.find(name1)->second;
  const String& bt2 = mapAtypeBtype.find(name2)->second;
  const String& bt3 = mapAtypeBtype.find(name3)->second;
  for(unsigned int j = 0; j < dihedraltypes.size(); ++j ) {
    if( funct != dihedraltypes[j].funct ) continue;
    String ni = dihedraltypes[j].namei;
    String nj = dihedraltypes[j].namej;
    String nk = dihedraltypes[j].namek;
    String nl = dihedraltypes[j].namel;
    if( ( (bt0 == ni || ni == "X") && bt1 == nj && bt2 == nk && (bt3 == nl || nl == "X") ) ||
        ( (bt3 == ni || ni == "X") && bt2 == nj && bt1 == nk && (bt0 == nl || nl == "X") ) || 
        ( (bt0 == ni || ni == "X") && (bt1 == nj || nj == "X") && bt2 == nk && (bt3 == nl ) ) 
        ) {
      int nX = 0;
      if( ni == "X" ) ++nX;
      if( nl == "X" ) ++nX;
      vi.push_back(j);
      vnX.push_back(nX);
    }
  }
  
  if( vi.empty() ) {
    cerr << "ERROR) Failed to set dihedral parameters for dihedral type "
         << name0 << " " << name1 << " " << name2 << " " << name3
         << " (" << i0 + 1 << " " << i1 + 1 << " " << i2 + 1 << " " << i3 + 1 << ")" << endl;
    cerr << "ERROR) Currently some patterns with wildcards are not supported, and this might be the reason of failed conversion." <<endl;
    cerr << "ERROR) In this case, you could try manually exend the wildcard beforehand." <<endl;
    return vi;
  }

  // Select only dihedraltypes with the least number of wildcards
  {
    int nXMin = *min_element(vnX.begin(), vnX.end());
    vector<int> vj;
    for(int i = 0; i < vi.size(); ++i) {
      if( vnX[i] == nXMin ) {
        vj.push_back(vi[i]);
      }
    }
    vi = vj;
  }

  if( funct != 9 )
    return vi;

  // Select only first match pattern
  vector<int> vi1;
  vector<int> vi2;
  {
    int j = vi[0];
    String namei = dihedraltypes[j].namei;
    String namej = dihedraltypes[j].namej;
    String namek = dihedraltypes[j].namek;
    String namel = dihedraltypes[j].namel;
    String name0 = namei + " " + namej + " " + namek + " " + namel;
    String name1 = namel + " " + namek + " " + namej + " " + namei;
    for(int i = 0; i < vi.size(); ++i) {
      int j = vi[i];
      String namei = dihedraltypes[j].namei;
      String namej = dihedraltypes[j].namej;
      String namek = dihedraltypes[j].namek;
      String namel = dihedraltypes[j].namel;
      String name = namei + " " + namej + " " + namek + " " + namel;
      if( name == name0 ) {
        vi1.push_back(vi[i]);
      }
      else if( name == name1 ) {
        vi2.push_back(vi[i]);
      }
    }
  }

  // remove duplicate parameters
  {
    vector<int> vj1;
    for(int i = 0; i < vi1.size(); ++i) {
      int ii = vi1[i];
      bool bDup = false;
      for(int j = 0; j < vj1.size(); ++j ) {
        int jj = vj1[j];
        bool bSame = true;
        if( dihedraltypes[ii].phase != dihedraltypes[jj].phase ) bSame = false;
        if( dihedraltypes[ii].kd    != dihedraltypes[jj].kd    ) bSame = false;
        if( dihedraltypes[ii].pn    != dihedraltypes[jj].pn    ) bSame = false;
        if( bSame ) {
          bDup = true;
          break;
        }
      }
      if( !bDup ) {
        vj1.push_back(ii);
      }
    }
    vi1 = vj1;
  }
  {
    vector<int> vj2;
    for(int i = 0; i < vi2.size(); ++i) {
      int ii = vi2[i];
      bool bDup = false;
      for(int j = 0; j < vj2.size(); ++j ) {
        int jj = vj2[j];
        bool bSame = true;
        if( dihedraltypes[ii].phase != dihedraltypes[jj].phase ) bSame = false;
        if( dihedraltypes[ii].kd    != dihedraltypes[jj].kd    ) bSame = false;
        if( dihedraltypes[ii].pn    != dihedraltypes[jj].pn    ) bSame = false;
        if( bSame ) {
          bDup = true;
          break;
        }        
      }
      if( !bDup ) {
        vj2.push_back(ii);
      }
    }
    vi2 = vj2;
  }

  // vi1 and v2i are only allowed same parameters and single line
  bool bError = false;
  if( !vi2.empty() ) {
    bError = true;
    if( vi2.size() == 1 && vi1.size() == 1 ) {
      bError = false;
      int i = vi1[0];
      int j = vi2[0];
      if( dihedraltypes[i].phase != dihedraltypes[j].phase ) bError = true;
      if( dihedraltypes[i].kd    != dihedraltypes[j].kd    ) bError = true;
      if( dihedraltypes[i].pn    != dihedraltypes[j].pn    ) bError = true;
    }
  }

  if( bError ) {
    cerr << "ERROR) Failed to set dihedral parameters for dihedral type "
         << name0 << " " << name1 << " " << name2 << " " << name3 << endl;
    cerr << "Encountered a second block of parameters for dihedral type 9 for the same" << endl
         << "atoms, with either different parameters and/or the first block has" << endl
         << "multiple lines. This is not supported." << endl;
    return vector<int>();
  }

  return vi1;
}

bool GromacsConverter::ConvertAngleToCell(double a, double b, double c, 
                                          double alpha, double beta, double gamma, 
                                          GROCELL& cell)
{
  if( fabs(alpha - 90.0) < 1.0e-5 && 
      fabs(beta  - 90.0) < 1.0e-5 && 
      fabs(gamma - 90.0) < 1.0e-5 ) {
    // cuboid
    cell.v1[0] = a;
    cell.v1[1] = 0.0;
    cell.v1[2] = 0.0;
    cell.v2[0] = 0.0;
    cell.v2[1] = b;
    cell.v2[2] = 0.0;
    cell.v3[0] = 0.0;
    cell.v3[1] = 0.0;
    cell.v3[2] = c;
  }
  else {
    alpha *= PI / 180.0;
    beta  *= PI / 180.0;
    gamma *= PI / 180.0;
    try {
      double ax = a;
      double ay = 0.0;
      double az = 0.0;
      double bx = b * cos(gamma);
      double by = b * sin(gamma);
      double bz = 0.0;
      double cx = c * cos(beta);
      double cy = ( b * c * cos(alpha) - bx * cx ) / by;
      double cz = sqrt( c * c - cx * cx - cy * cy );
      cell.v1[0] = ax;
      cell.v1[1] = ay;
      cell.v1[2] = az;
      cell.v2[0] = bx;
      cell.v2[1] = by;
      cell.v2[2] = bz;
      cell.v3[0] = cx;
      cell.v3[1] = cy;
      cell.v3[2] = cz;
    }
    catch(...) {
      cerr << "ERROR) Invalid cell parameters" << endl;
      return false;
    }
  }

  return true;
}

bool GromacsConverter::Modylas2Gromacs( const ModylasData& mod_data, GromacsData& gmx_data )
{
  //cout << "Info) Converting MODYLAS to Gromacs ..." << endl;

  // mdxyz tag to GROATOMs and GROCELL
  {
    vector<GROATOM>& atoms = gmx_data.m_groatoms;
    GROCELL&         cell  = gmx_data.m_grocell;

    // periodic cell parameters
    const ModylasTagData* pcell_tag = mod_data.m_mdxyz_root_tag.GetTagData("periodic cell");
    if( !pcell_tag ) {
      cerr << "ERROR) /periodic cell not found." << endl;
      return false;
    }

    const ModylasTagData* length_tag = pcell_tag->GetTagData("length");
    double a = 0.0;
    double b = 0.0;
    double c = 0.0;
    if( length_tag ) {
      vector<String> vstrlen = length_tag->GetStrings();
      if( vstrlen.size() != 3 ) {
        cerr << "ERROR) invalid number of words in /periodic cell/length."
             << endl;
        return false;
      }
      a = (float)atof( vstrlen[0].c_str() ) * A_TO_NM;
      b = (float)atof( vstrlen[1].c_str() ) * A_TO_NM;
      c = (float)atof( vstrlen[2].c_str() ) * A_TO_NM;
    }

    double alpha = 90.0;
    double beta  = 90.0;
    double gamma = 90.0;
    const ModylasTagData* angle_tag = pcell_tag->GetTagData("angle");
    if( angle_tag ) {
      vector<String> strang = angle_tag->GetStrings();
      if( strang.size() != 3 ) {
        cerr << "ERROR) invalid number of words in /periodic cell/angle."
             << endl;
        return false;
      }
      alpha = (float)atof( strang[0].c_str() );
      beta  = (float)atof( strang[1].c_str() );
      gamma = (float)atof( strang[2].c_str() );
    }
    if( !ConvertAngleToCell(a, b, c, alpha, beta, gamma, cell) ) {
      cerr << "ERROR) Failed to convert cell angles to vetors." << endl;
      return false;
    }

    // atoms
    const ModylasTagData* atom_tag = mod_data.m_mdxyz_root_tag.GetTagData( "atom" );
    if( !atom_tag ) {
      cerr << "ERROR) /atom not found." << endl;
      return false;
    }

    String strnatom = atom_tag->GetValue( "natom" );
    if( strnatom == "" ) {
      cerr << "ERROR) /atom/natom key not found." << endl;
      return false;
    }
    int natoms = atoi( strnatom.c_str() );

    gmx_data.m_groatoms.resize( natoms );

    // read positions
    const ModylasTagData* positions_tag = atom_tag->GetTagData("positions");
    if( !positions_tag ) {
      cerr << "ERROR) /atom/positions not found." << endl;
      return false;
    }

    vector<String> vstrpos = positions_tag->GetStrings();
    if( (int)vstrpos.size() != 3 * natoms ) {
      cerr << "ERROR) Inconsistent number of words in /atom/positions."
           << endl;
      return false;
    }

    double move[3];
    move[0] = ( cell.v1[0] + cell.v2[0] + cell.v3[0] ) * 0.5;
    move[1] = ( cell.v1[1] + cell.v2[1] + cell.v3[1] ) * 0.5;
    move[2] = ( cell.v1[2] + cell.v2[2] + cell.v3[2] ) * 0.5;
    for( int i = 0; i < natoms; ++i ) {
      for( int j = 0; j < 3; ++j ) {
        double d = (float)atof( vstrpos[3*i+j].c_str() ) * A_TO_NM + move[j];
        gmx_data.m_groatoms[i].pos[j] = d;
      }
    }

    const ModylasTagData* velocities_tag = atom_tag->GetTagData("velocities");
    if( velocities_tag ) {
      vector<String> vstrvel = velocities_tag->GetStrings();
      if( (int)vstrvel.size() != 3 * natoms ) {
        cerr << "ERROR) Inconsistent number of words in /atom/velocities."
             << endl;
        return false;
      }
      for( int i = 0; i < natoms; ++i ) {
        for( int j = 0; j < 3; ++j ) {
          gmx_data.m_groatoms[i].vel[j] = (float)atof( vstrvel[3*i+j].c_str() )
            * A_TO_NM * 1.0e-12;
        }
      }
    }
  }

  // mdff to top parameters
  {
    const ModylasTagData& root_tag = mod_data.m_mdff_root_tag;
    const ModylasTagData* system_tag = root_tag.GetTagData( "system" );
    if( !system_tag ) {
      cerr << "ERROR) /system not found." << endl;
      return false;
    }
    
    vector<String> vstrsys = system_tag->GetStrings();
    if( vstrsys.size() % 2 == 1 ) {
      cerr << "ERROR) Invalid number of words in /system." << endl;
      return false;
    }

    int nspecies = vstrsys.size() / 2;
    gmx_data.m_mols.resize(nspecies);
    for( int i = 0; i < nspecies; ++i ) {
      int ispecies = atoi( vstrsys[2*i  ].c_str() );
      int nmol     = atoi( vstrsys[2*i+1].c_str() );
      if( ispecies >= nspecies || nmol <= 0 ) {
        cerr << "ERROR) Invalid integer number in /system." << endl;
        return false;
      }
      gmx_data.m_mols[i].molname = "M" + String(i + 1);
      gmx_data.m_mols[i].nmol    = nmol;
    }

    const ModylasTagData* topo_tag = root_tag.GetTagData( "topology and parameters" );
    if( !topo_tag ) {
      cerr << "ERROR) /topology and parameters not found." << endl;
      return false;
    }

    String strnspecies = topo_tag->GetValue("nspecies");
    if( strnspecies == "" ) {
      cerr << "ERROR) /topology and parameters/nspecies not found." << endl;
      return false;
    }
  
    if( nspecies != atoi( strnspecies.c_str() ) ) {
      cerr << "ERROR) Inconsistent value of /topology and parameters/nspecies."
           << endl;
      return false;
    }

    vector<ModylasTagData*> spec_tags = topo_tag->GetTagDatas("species");
    if( nspecies != (int)spec_tags.size() ) {
      cerr << "ERROR) Inconsistent number of /topology and parameters/species."
           << endl;
      return false;
    }

    map<String, TOPATOMTYPE> mapAtomTypeCmap;

    gmx_data.m_moltypes.resize(nspecies);
    for( int ispec = 0; ispec < nspecies; ++ispec ) {
      const ModylasTagData* spec_tag = spec_tags[ispec];
      
      String strid = spec_tag->GetValue("id");
      if( strid == "" ) {
        cerr << "ERROR) /topology and parameters/species/id not found." << endl;
        return false;
      }
      int id = atoi( strid.c_str() );
      if( nspecies <= id ) {
        cerr << "ERROR) Invalid Value of /topology and parameters/species/id." << endl;
        return false;
      }

      TOPMOLECULETYPE& moltype = gmx_data.m_moltypes[id];
      moltype.name = gmx_data.m_mols[id].molname;
      
      String strnatom = spec_tag->GetValue("natom");
      if( strnatom == "" ) {
        cerr << "ERROR) /topology and parameters/species/natom not found." 
             << endl;
        return false;
      }
      int natom = atoi( strnatom.c_str() );

      { // [ atoms ]
        moltype.atoms.resize(natom);

        // get mass
        const ModylasTagData* mass_tag = spec_tag->GetTagData( "mass" );
        if( !mass_tag ) {
          cerr << "ERROR) /topology and parameters/species/mass not found." << endl;
          return false;
        }
        vector<String> vsMass = mass_tag->GetStrings();
        if( (int)vsMass.size() != natom ) {
          cerr << "ERROR) Inconsistent number of words in " 
               << "/topology and parameters/species/mass."
               << endl;
          return false;
        }

        // get charge
        const ModylasTagData* charge_tag = spec_tag->GetTagData( "charge" );
        if( !charge_tag ) {
          cerr << "ERROR) /topology and parameters/species/charge not found."
               << endl;
          return false;
        }
        vector<String> vsCharge = charge_tag->GetStrings();
        if( (int)vsCharge.size() != natom ) {
          cerr << "ERROR) inconsistent number of words in "
               << "/topology and parameters/species/charge."
               << endl;
          return false;
        }

        try {
          vector<int> vcgnr(natom, 0);
          const ModylasTagData* segs_tag = spec_tag->GetTagData( "segments" );
          if( !segs_tag ) {
            cerr << "ERROR) /topology and parameters/species/segments not found."
                 << endl;
            return false;
          }
          vector<ModylasTagData*> vseg_tag = segs_tag->GetTagDatas( "segment" );
          for( unsigned int i = 0; i < vseg_tag.size(); ++i ) {
            String strid = vseg_tag[i]->GetValue  ( "ID" );
            int cgnr = strid.ToInt() + 1;
            const ModylasTagData* atom_tag = vseg_tag[i]->GetTagData( "atom" );
            vector<String> vsAtom = atom_tag->GetStrings();
            for( unsigned int j = 0; j < vsAtom.size(); ++j ) {
              int iAtom = vsAtom[j].ToInt();
              vcgnr[iAtom] = cgnr;
            }
          }

          map<String, int> mapElemNum;
          for( int i = 0; i < natom; ++i ) {
            double mass = vsMass[i].ToDouble();
            String name = ModylasUtil::GetMassElement( mass );
            map<String, int>::iterator it = mapElemNum.find(name);
            String striElem;
            if( it == mapElemNum.end() ) {
              mapElemNum[name] = 1;
              striElem = "1";
            }
            else {
              ++it->second;
              striElem = String(it->second);
            }
            name += striElem;
            moltype.atoms[i].type    = moltype.name + "_" + name;
            moltype.atoms[i].resid   = 1;
            moltype.atoms[i].resname = moltype.name;
            moltype.atoms[i].name    = name;
            moltype.atoms[i].cgnr    = vcgnr[i];
            moltype.atoms[i].charge  = vsCharge[i].ToDouble();
            moltype.atoms[i].mass    = mass;
            moltype.atoms[i].bHasCharge = true;
            moltype.atoms[i].bHasMass   = true;
          }
        }
        catch(...) {
          cerr << "ERROR) Invalid value of mass, charge, sigma or epsilon." 
               << endl;
          return false;
        }
      }

      { // [ bonds ]
        String strnbond = spec_tag->GetValue("nbond");
        if( strnbond == "" ) {
          cerr << "ERROR) /topology and parameters/species/nbond not found." 
               << endl;
          return false;
        }
        int nbond = atoi( strnbond.c_str() );
        
        const ModylasTagData* bond_tag = spec_tag->GetTagData( "bond" );
        if( !bond_tag ) {
          cerr << "ERROR) /topology and parameters/species/bond not found." << endl;
          return false;
        }
        
        vector<String> bondstrs = bond_tag->GetStrings();
        if( (int)bondstrs.size() != nbond * 4 ) {
          cerr << "ERROR) inconsistent number of words in "
               << "/topology and parameters/species/bond."
               << endl;
          return false;
        }

        try {
          for( int i = 0; i < nbond; ++i ) {
            TOPBOND bond;
            bond.ai = atoi( bondstrs[4*i+0].c_str() ) + 1;
            bond.aj = atoi( bondstrs[4*i+1].c_str() ) + 1;
            bond.k  = atof( bondstrs[4*i+2].c_str() );
            bond.r  = atof( bondstrs[4*i+3].c_str() );
            bond.k *= 2.0 * KCAL_TO_KJ * NM_TO_A * NM_TO_A;
            bond.r *= A_TO_NM;
            bond.bHasR = true;
            moltype.bonds.push_back(bond);
          }
        }
        catch(...) {
          cerr << "ERROR) Invalid value of bond parameters." 
               << endl;
          return false;
        }

        const ModylasTagData* shake_tag = spec_tag->GetTagData( "shake pair" );
        if( !shake_tag ) {
          cerr << "ERROR) /topology and parameters/species/shake pair not found." << endl;
          return false;
        }
        
        vector<String> shakestrs = shake_tag->GetStrings();
        if( shakestrs.size() % 3 != 0 ) {
          cerr << "ERROR) inconsistent number of words in "
               << "/topology and parameters/species/shake pair."
               << endl;
          return false;
        }

        try {
          for( unsigned int i = 0; i < shakestrs.size() / 3; ++i ) {
            TOPBOND shake;
            shake.ai = atoi( shakestrs[3*i+0].c_str() ) + 1;
            shake.aj = atoi( shakestrs[3*i+1].c_str() ) + 1;
            shake.r  = atof( shakestrs[3*i+2].c_str() ) * A_TO_NM;
            shake.k  = 3.0e5;
            shake.bHasR = true;
            moltype.bonds.push_back(shake);
          }
        }
        catch(...) {
          cerr << "ERROR) Invalid value of shake parameters." 
               << endl;
          return false;
        }
      }
      
      { // [ pairs ]
        String snljspecial = spec_tag->GetValue( "nspecialpair_lj" );
        if( snljspecial != "" ) {
          int nljspecial = 0;
          try {
            nljspecial = snljspecial.ToInt();
          }
          catch(...) {
            cerr << "ERROR) Invalid value of lj special pair number." 
                 << endl;
            return false;
          }
          vector<String> vljspecial = spec_tag->GetTagData( "lj special pair" )->GetStrings();
          if( (int)vljspecial.size() != nljspecial * 4 ) {
            cerr << "ERROR) inconsistent number of words in "
                 << "/topology and parameters/species/lj special pair"
                 << endl;
            return false;
          }

          try {
            for( int i = 0; i < nljspecial; ++i ) {
              TOPPAIR pair;
              pair.ai    = vljspecial[i*4  ].ToInt() + 1;
              pair.aj    = vljspecial[i*4+1].ToInt() + 1;
              pair.bHasSigma = true;
              pair.sigma   = vljspecial[i*4+3].ToDouble() * R_TO_SIGMA * A_TO_NM; // A -> nm
              pair.epsilon = vljspecial[i*4+2].ToDouble() * KCAL_TO_KJ; // kcal/mol -> KJ/mol
              moltype.pairs.push_back(pair);
            }
          }
          catch(...) {
            cerr << "ERROR) Invalid value of lj special pair parameters." 
                 << endl;
            return false;
          }
        }
      }

      { // [ angles ]
        map<int3, TOPANGLE> mapUB;
        int nub = spec_tag->GetValue("nub" ).ToInt();
        vector<String> vub = spec_tag->GetTagData( "ub" )->GetStrings();
        if( (int)vub.size() != nub * 5 ) {
          cerr << "ERROR) inconsistent number of words in "
               << "/topology and parameters/species/ub"
               << endl;
          return false;
        }
        try {
          for( int i = 0; i < nub; ++i ) {
            TOPANGLE ub;
            ub.ai    = vub[i*5  ].ToInt() + 1;
            ub.aj    = vub[i*5+1].ToInt() + 1;
            ub.ak    = vub[i*5+2].ToInt() + 1;
            ub.bHasThetaK = true;
            ub.ub0   = vub[i*5+4].ToDouble() * A_TO_NM;
            ub.cub   = vub[i*5+3].ToDouble() * 2.0
              * KCAL_TO_KJ / (A_TO_NM * A_TO_NM); // kcal/mol/A^2 -> KJ/mol/A^2
            mapUB[int3(ub.ai, ub.aj, ub.ak)] = ub;
          }
        }
        catch(...) {
          cerr << "ERROR) Invalid value of ub parameters." 
               << endl;
          return false;
        }
          
        int nangle = spec_tag->GetValue("nangle" ).ToInt();
        vector<String> vangle = spec_tag->GetTagData( "angle" )->GetStrings();
        if( (int)vangle.size() != nangle * 5 ) {
          cerr << "ERROR) inconsistent number of words in "
               << "/topology and parameters/species/angle"
               << endl;
          return false;
        }
        try {
          for( int i = 0; i < nangle; ++i ) {
            TOPANGLE angle;
            angle.ai    = vangle[i*5  ].ToInt() + 1;
            angle.aj    = vangle[i*5+1].ToInt() + 1;
            angle.ak    = vangle[i*5+2].ToInt() + 1;
            angle.funct = 1;
            angle.bHasThetaK = true;
            angle.theta = vangle[i*5+4].ToDouble();
            angle.k     = vangle[i*5+3].ToDouble() * 2.0
              * KCAL_TO_KJ; // kcal/mol/rad^2 -> KJ/mol/rad^2
            int3 aijk(angle.ai, angle.aj, angle.ak);
            int3 akji(angle.ak, angle.aj, angle.ai);
            map<int3, TOPANGLE>::iterator it = mapUB.find(aijk);
            if( it == mapUB.end() ) {
              it = mapUB.find(akji);
            }
            if( it != mapUB.end() ) {
              angle.funct  = 5;
              angle.bHasUB = true;
              angle.ub0    = it->second.ub0;
              angle.cub    = it->second.cub;
            }
            moltype.angles.push_back(angle);
          }
        }
        catch(...) {
          cerr << "ERROR) Invalid value of angle parameters." 
               << endl;
          return false;
        }
      }

      { // [ dihedrals ]
        int ndihedral = spec_tag->GetValue("ndihedral" ).ToInt();
        vector<String> vdihedral = spec_tag->GetTagData( "dihedral" )->GetStrings();
        if( (int)vdihedral.size() != ndihedral * 7 ) {
          cerr << "ERROR) inconsistent number of words in "
               << "/topology and parameters/species/dihedral"
               << endl;
          return false;
        }
        try {
          for( int i = 0; i < ndihedral; ++i ) {
            TOPDIHEDRAL dihedral;
            dihedral.ai    = vdihedral[i*7  ].ToInt() + 1;
            dihedral.aj    = vdihedral[i*7+1].ToInt() + 1;
            dihedral.ak    = vdihedral[i*7+2].ToInt() + 1;
            dihedral.al    = vdihedral[i*7+3].ToInt() + 1;
            dihedral.funct = 9;
            dihedral.bHasPhase = true;
            dihedral.phase = vdihedral[i*7+6].ToDouble();
            dihedral.kd    = vdihedral[i*7+4].ToDouble() * KCAL_TO_KJ; //kcal/mol -> KJ/mol
            dihedral.bHasN = true;
            dihedral.pn    = vdihedral[i*7+5].ToInt();
            moltype.dihedrals.push_back(dihedral);
          }
        }
        catch(...) {
          cerr << "ERROR) Invalid value of dihedral parameters." 
               << endl;
          return false;
        }

        int nitorsion = spec_tag->GetValue("nitorsion" ).ToInt();
        vector<String> vitorsion = spec_tag->GetTagData( "itorsion" )->GetStrings();
        if( (int)vitorsion.size() != nitorsion * 6 ) {
          cerr << "ERROR) inconsistent number of words in "
               << "/topology and parameters/species/itorsion"
               << endl;
          return false;
        }
        try {
          for( int i = 0; i < nitorsion; ++i ) {
            TOPDIHEDRAL itorsion;
            itorsion.ai    = vitorsion[i*6  ].ToInt() + 1;
            itorsion.aj    = vitorsion[i*6+1].ToInt() + 1;
            itorsion.ak    = vitorsion[i*6+2].ToInt() + 1;
            itorsion.al    = vitorsion[i*6+3].ToInt() + 1;
            itorsion.funct = 2;
            itorsion.bHasPhase = true;
            itorsion.phase = vitorsion[i*6+5].ToDouble();
            itorsion.kd    = vitorsion[i*6+4].ToDouble()
              * 2.0 * KCAL_TO_KJ; //kcal/mol -> KJ/mol
            itorsion.bHasN = false;
            itorsion.pn    = 1;
            moltype.dihedrals.push_back(itorsion);
          }
        }
        catch(...) {
          cerr << "ERROR) Invalid value of itorsion parameters." 
               << endl;
          return false;
        }
      }

      { // [ cmap ]
        String sncmap = spec_tag->GetValue("ncmap" );
        if( sncmap != "" ) {
          int ncmap = sncmap.ToInt();
          vector<String> vcmap = spec_tag->GetTagData( "cmap" )->GetStrings();
          if( (int)vcmap.size() != ncmap * 6 ) {
            cerr << "ERROR) inconsistent number of words in "
                 << "/topology and parameters/species/cmap"
                 << endl;
            return false;
          }
          try {
            for( int i = 0; i < ncmap; ++i ) {
              TOPCMAP cmap;
              cmap.ai = vcmap[i*6  ].ToInt() + 1;
              cmap.aj = vcmap[i*6+1].ToInt() + 1;
              cmap.ak = vcmap[i*6+2].ToInt() + 1;
              cmap.al = vcmap[i*6+3].ToInt() + 1;
              cmap.am = vcmap[i*6+4].ToInt() + 1;
              moltype.cmaps.push_back(cmap);

              // modify type of [ atoms ]
              String names = "";
              switch( vcmap[i*6+5].ToInt() ) {
              case 1: names = "C NH1 CT1 C NH1"; break;
              case 2: names = "C NH1 CT1 C N";   break;
              case 3: names = "C N CP1 C NH1";   break;
              case 4: names = "C N CP1 C N";     break;
              case 5: names = "C NH1 CT2 C NH1"; break;
              case 6: names = "C NH1 CT2 C N";   break;
              }
              if( names == "" ) {
                cerr << "ERROR) Invalid value in "
                     << "/topology and parameters/species/cmap"
                     << endl;
                return false;
              }
              vector<String> vNames = names.Split();
              moltype.atoms[cmap.ai - 1].type = vNames[0];
              moltype.atoms[cmap.aj - 1].type = vNames[1];
              moltype.atoms[cmap.ak - 1].type = vNames[2];
              moltype.atoms[cmap.al - 1].type = vNames[3];
              moltype.atoms[cmap.am - 1].type = vNames[4];
            }
          }
          catch(...) {
            cerr << "ERROR) Invalid value of cmap parameters." 
                 << endl;
            return false;
          }
        }
      }

      { // [ atomtypes ]
        // get sigma
        const ModylasTagData* r_tag = spec_tag->GetTagData( "r" );
        if( !r_tag ) {
          cerr << "ERROR) /topology and parameters/species/r not found."
               << endl;
          return false;
        }
        vector<String> vsR = r_tag->GetStrings();
        if( (int)vsR.size() != natom ) {
          cerr << "ERROR) inconsistent number of words in "
               << "/topology and parameters/species/r ."
               << endl;
          return false;
        }

        // get epsilon
        const ModylasTagData* eps_tag = spec_tag->GetTagData( "epsilon" );
        if( !eps_tag ) {
          cerr << "ERROR) /topology and parameters/species/epsilon not found."
               << endl;
          return false;
        }
        vector<String> vsEps = eps_tag->GetStrings();
        if( (int)vsEps.size() != natom ) {
          cerr << "ERROR) inconsistent number of words in "
               << "/topology and parameters/species/epsilon."
               << endl;
          return false;
        }

        try {
          for( int i = 0; i < natom; ++i ) {
            String type = moltype.atoms[i].type;
            TOPATOMTYPE atype;
            atype.name    = type;
            atype.btype   = type;
            atype.mass    = moltype.atoms[i].mass;
            atype.charge  = moltype.atoms[i].charge;
            atype.sigma   = vsR  [i].ToDouble() * R_TO_SIGMA * A_TO_NM;
            atype.epsilon = vsEps[i].ToDouble() * KCAL_TO_KJ;
            if( type.Split("_")[0] == moltype.name ) {
              gmx_data.m_atomtypes.push_back(atype);
            }
            else {
              if( mapAtomTypeCmap.find(type) == mapAtomTypeCmap.end() ) {
                mapAtomTypeCmap[type] = atype;
              }
              else {
                if( ( mapAtomTypeCmap[type].mass    != atype.mass    ) ||
                    ( mapAtomTypeCmap[type].charge  != atype.charge  ) ||
                    ( mapAtomTypeCmap[type].sigma   != atype.sigma   ) ||
                    ( mapAtomTypeCmap[type].epsilon != atype.epsilon ) ) {
                  cerr << "ERROR) Same cmap type atoms are differnet atom type"
                       << endl;
                  return false;
                }
              }
            }
          }
        }
        catch(...) {
          cerr << "ERROR) Invalid value of mass, charge, sigma or epsilon." 
               << endl;
          return false;
        }
      }
    } // loop species

    // add atomtypes for cmap
    map<String, TOPATOMTYPE>::iterator it = mapAtomTypeCmap.begin();
    for( ; it != mapAtomTypeCmap.end(); ++it ) {
      gmx_data.m_atomtypes.push_back(it->second);
    }
  }

  { // set residues and names to GROATOMs
    int iAtom = 0;
    int iRes  = 1;
    for( unsigned int ispec = 0; ispec < gmx_data.m_moltypes.size(); ++ispec ) {
      const TOPMOLECULETYPE& moltype = gmx_data.m_moltypes[ispec];
      for( int j = 0; j< gmx_data.m_mols[ispec].nmol; ++j ) {
        for( unsigned int i = 0; i < moltype.atoms.size(); ++i ) {
          gmx_data.m_groatoms[iAtom].resid   = iRes;
          gmx_data.m_groatoms[iAtom].resname = moltype.name;
          gmx_data.m_groatoms[iAtom].name    = moltype.atoms[i].name;
          ++iAtom;
        }
        ++iRes;
      }
    }
  }
  
  return true;
}

bool GromacsConverter::ConvertMdpToMddef( const String& strSessionName )
{
  String strMdp = String::ReadFileString(strSessionName + ".mdp");
  
  map<String, String> mapMdp;
  
  vector<String> lines = strMdp.Split("\n");
  for(int i = 0; i < lines.size() - 1; ++i) {
    String line = lines[i];
    int iPos = line.find(";");
    if( iPos != string::npos ) {
      line = line.substr(0, iPos);
    }
    vector<String> tokens = line.Split("=");
    if( tokens.size() != 2 ) continue;
    String strKey = tokens[0].Trim().ToLower();
    String strVal = tokens[1].Trim();
    mapMdp[strKey] = strVal;
  }

  ModylasTagData root_tag = ModylasTagData();
  root_tag.AddTagData( "header" );
  root_tag.AddTagData( "output" );
  root_tag.AddTagData( "integrator" );
  root_tag.AddTagData( "ensemble" );
  root_tag.AddTagData( "intermolecular interaction" );

  typedef struct {
    String strMdpKey;
    String strMdpVal;
    String strMddefKey;
    String strMddefVal;
    String (*ConvertFunc)(const String&);

    // picosecond to second
    static String PS2S(const String& s) {
      return String(s.ToDouble() * 1.0e-12);
    }

    // nano meter to angstrom
    static String NM2A(const String& s) {
      return String(s.ToDouble() * 10.0);
    }

    // Extract first param
    static String First(const String& s) {
      return s.Split()[0];
    }

    // nano meter to angstrom for first param only
    static String NM2A1(const String& s) {
      return String(First(s).ToDouble() * 10.0);
    }

    // bar to Pa
    static String Bar2Pa(const String& s) {
      return String(s.ToDouble() * 1.0e+5);
    }
  } AttrTable;

  AttrTable tables[] = { 
    {"integrator", "md"    , "/ensemble/ensemble", "nve"                                 , NULL},
    {"integrator", "sd"    , "/ensemble/"        , "# %k not supported by this converter", NULL},
    {"integrator", "steep" , "/ensemble/ensemble", "opt"                                 , NULL},
    {"integrator", "l-bfgs", "/ensemble/ensemble", "opt"                                 , NULL},
    {"dt"        , ""      , "/integrator/dt"    , "%v # Unit convertsion to [sec]"      , AttrTable::PS2S},
    {"nsteps"    , ""      , "/integrator/steps" , "%v"                                  , NULL},

    {"emtol" , "", "/integrator/optimize/"           , "# %k not supported by this converter", NULL},
    {"emstep", "", "/integrator/optimize/step_length", "%v # Unit convertsion to [angstrom]" , AttrTable::NM2A},

    {"nstxout"           , "", "/output/trajectory/interval", "%v"                                  , NULL},
    {"nstxout"           , "", "/output/"                   , "# dcd = yes"                         , NULL},
    {"nstxout"           , "", "/output/"                   , "# <trjdcd>interval=%v</trjdcd>"      , NULL},
    {"nstvout"           , "", "/output/trajectory/"        , "# %k not supported by this converter", NULL},
    {"nstfout"           , "", "/output/trajectory/"        , "# %k not supported by this converter", NULL},
    {"nstlog"            , "", "/output/trajectory/"        , "# %k not supported by this converter", NULL},
    {"nstenergy"         , "", "/output/monitor/interval"   , "%v"                                  , NULL},
    {"nstxout-compressed", "", "/output/xtc"                , "yes"                                 , NULL},
    {"nstxout-compressed", "", "/output/xtc/trjxtc/interval", "%v"                                  , NULL},
    {"nstxout-compressed", "", "/output/"                   , "# xtc=yes requires MODYLAS compiled with -DXTC = ON", NULL},
    {"compressed-x-grps" , "", "/output/xtc/"               , "# %k not supported by this converter (whole system only in MODYLAS)", NULL},

    {"cutoff-scheme", "", "/intermolecular interaction/", "# %k not supported by this converter", NULL},
    {"nstlist"      , "", "/intermolecular interaction/", "# %k not supported by this converter", NULL},
    {"ns_type"      , "", "/intermolecular interaction/", "# %k not supported by this converter", NULL},
    {"pbc"          , "", "/intermolecular interaction/", "# %k not supported by this converter", NULL},

    {"coulombtype", "PME", "/intermolecular interaction/type"        , "fmm # pme is not supported, so fmm is selected", NULL},
    {"coulombtype", "PME", "/intermolecular interaction/fmm/nmax"    , "4"                                             , NULL},
    {"coulombtype", "PME", "/intermolecular interaction/fmm/ULswitch", "0"                                             , NULL},
    {"coulombtype", "PME", "/intermolecular interaction/fmm/sterm"   , "no"                                            , NULL},
    {"rcoulomb"   , ""   , "/intermolecular interaction/"            , "# %k not supported by this converter"          , NULL},

    {"vdw-modifier", "Potential-shift-Verlet", "/intermolecular interaction/"                    , "# %k not supported by this converter", NULL},
    {"vdw-modifier", "Force-switch"          , "/header/"                                        , "# force-switch requires MODYLAS compiled with -DCHARMMFSW", NULL},

    {"vdw-modifier", "Force-switch"          , "/intermolecular interaction/twobody/LJcorrection", "no"                                  , NULL},
    {"rvdw"        , ""                      , "/intermolecular interaction/twobody/cutoff"      , "%v"                                  , AttrTable::NM2A},

    {"DispCorr", "no"      , "/intermolecular interaction/twobody/LJcorrection", "no"                                  , NULL},
    {"DispCorr", "EnerPres", "/intermolecular interaction/twobody/LJcorrection", "yes"                                 , NULL},
    {"DispCorr", "Ener"    , "/intermolecular interaction/twobody/"            , "# %k not supported by this converter", NULL},

    {"fourierspacing", "", "/intermolecular interaction/", "# %k not supported by this converter", NULL},
    {"pme_order"     , "", "/intermolecular interaction/", "# %k not supported by this converter", NULL},

    {"tcoupl" , "v-rescale", "/ensemble/ensemble"       , "nvt"                                                  , NULL},
    {"tc-grps", ""         , "/ensemble/"               , "# %k not supported by this converter"                 , NULL},
    {"tau-t"  , ""         , "/ensemble/themostat/tau_Q", "%v # Unit conversion to [sec] (only the first param.)", AttrTable::NM2A1},
    {"tau-t"  , ""         , "/ensemble/barostat/tau_Q" , "%v # Unit conversion to [sec] (only the first param.)", AttrTable::NM2A1},
    {"tau-t"  , ""         , "/ensemble/barostat/"      , "# Thermostat tau_Q is a heat bath for particle system. Barostat tau_Q is a heat bath for piston", NULL},
    {"ref-t"  , ""         , "/ensemble/temperature"    , "%v # the first param. only"                           , AttrTable::First},

    {"pcoupl"          , "Parrinello-Rahman", "/ensemble/ensemble"      , "npt_z # or npt_pr"                   , NULL},
    {"pcoupl"          , "isotropic"        , "/ensemble/ensemble"      , "npt_a"                               , NULL},
    {"tau-p"           , ""                 , "/ensemble/barostat/tau_W", "%v # Unit conversion to [sec]"       , AttrTable::NM2A1},
    {"compressibility" , ""                 , "/ensemble/barostat/"     , "# %k not supported by this converter", NULL},
    {"ref-p"           , ""                 , "/ensemble/pressure"      , "%v # Unit conversion to [Pa]"        , AttrTable::Bar2Pa},
    {"refcoord-scaling", "com"              , "/ensemble/"              , "# %k not supported by this converter (Because it always scales in atomic units)", NULL},

    {"gen-vel" , "no" , "/ensemble/maxwell_velocities", "no"                                         , NULL},
    {"gen-vel" , "yes", "/ensemble/maxwell_velocities", "yes"                                        , NULL},
    {"gen-temp", ""   , "/ensemble/"                  , "# MODYLAS uses /ensemble/temperature for %k", NULL},
    {"gen-seed", ""   , "/ensemble/"                  , "# %k not supported by this converter"       , NULL},

    {"constraints"         , "h-bonds", "/", "# %k not supported by this converter. The bonds should be specified in <shake> of .mdff dile", NULL},
    {"constraint-algorithm", "LINCS"  , "/", "# %k not supported by this converter", NULL},
    {"continuation"        , "no"     , "/", "# %k not supported by this converter", NULL},
    {"continuation"        , "yes"    , "/", "# %k not supported by this converter", NULL},
    {"lincs-order"         , ""       , "/", "# %k not supported by this converter", NULL},
    {"lincs-iter"          , ""       , "/", "# %k not supported by this converter", NULL},
  };

  int n = sizeof(tables) / sizeof(tables[0]);
  for(int i = 0; i < n; ++i) {
    const AttrTable& table = tables[i];

    if( mapMdp.find(table.strMdpKey.ToLower()) == mapMdp.end() )
      continue;

    String strVal = mapMdp[table.strMdpKey.ToLower()];
    if( table.strMdpVal != "" && table.strMdpVal.ToLower() != strVal.ToLower() )
      continue;

    if( table.ConvertFunc != NULL ) {
      strVal = table.ConvertFunc(strVal);
    }

    strVal = table.strMddefVal.ReplaceAll("%v", strVal);
    strVal = strVal.ReplaceAll("%k", table.strMdpKey);

    vector<String> mddef_elems = table.strMddefKey.Split("/", false);

    ModylasTagData* tag = &root_tag;
    for(int j = 1; j < mddef_elems.size() - 1; ++j) {
      ModylasTagData* child_tag = tag->GetTagData(mddef_elems[j]);
      if( child_tag == NULL ) {
        tag = tag->AddTagData(mddef_elems[j]);
      }
      else {
        tag = child_tag;
      }
    }
    if( mddef_elems.back() == "" ) {
      tag->AddString(strVal);
    }
    else {
      tag->AddKeyValue(mddef_elems.back(), strVal);
    }
  }

  String strMddef;

  const vector<String>& strs = root_tag.GetTagData("header")->GetStrings();
  for(int i = 0; i < strs.size(); ++i) {
    strMddef += strs[i] + "\n";
  }
  root_tag.RemoveTagData("header");
  strMddef += root_tag.WriteDataString();

  String mddeffile = strSessionName + ".mddef.rst";
  ofstream ofs( mddeffile.c_str() );
  if( ofs.fail() ) {
    cerr << "Error) Could not open " + mddeffile + " for writing." << endl;
    return false;
  }
  ofs << strMddef << endl;
  ofs.close();

  return true;
}


